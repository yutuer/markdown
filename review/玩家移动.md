### 玩家移动

1. handler:   PacketIDConst.CSUnitMove

2. doMoveTo

   1.  不是正常移动的时候

      1. 如果正在移动, 打断移动, 并切换到普通移动

         ```java
         // 切换到普通移动
         if(curMoveModeEnum != MoveModeEnum.NORMAL)
         {
             if(curMoveMode.isMoving())
             {
                 curMoveMode.breakMove(false);
             }
         
             rs = switchMoveMode0(MoveModeEnum.NORMAL,false);
             if(rs < 0)
             {
                 return rs;
             }
         }
         ```

      2.  切换移动模式

         ```java
         int switchMoveMode0(MoveModeEnum nextMoveModeEnum, boolean isNotify){
         	AbstractMoveMode moveMode = getMoveMode(nextMoveModeEnum);
         
             // 退出模式前需要打断移动
             if(curMoveMode.isMoving())
             {
                 curMoveMode.breakMove(false);
             }
             curMoveMode.onExitMode();
         
             this.lastMoveModeEnum = curMoveModeEnum;
             this.curMoveModeEnum = nextMoveModeEnum;
         
             // 切换
             curMoveMode = moveMode;
         
             curMoveMode.onEnterMode();    
         }
         ```

      3.  检查是否可移动

         1. 检查终点可走

            ```java
            // 检验终点是否可走
            rs = checkPositionWalkable(moveList.get(size - 3), moveList.get(size - 2), moveList.get(size - 1));
            if (rs < 0)
            {
                return rs;
            }
            ```

         2. 检查当前点是否可走

            ```java
            // 检验当前点是否可走
            rs = checkClientNowPosition(nowX, nowY, nowZ, -1);
            if (rs < 0)
            {
                return rs;
            }
            ```

      4. 做一些清理的工作

         ```java
         // 移动前，清之前的路点
         onBeforeMove();
         
         // 记录客户端位置
         moveChecker.onMoveTo(nowX, nowY, nowZ);
         ```

      5. 添加路点到玩家的移动路径集合(使用一个队列)

         ```java
         AbstractCharacter character = getMoveModule().getCharacter();
         if(character.getX() != nowX && character.getZ() != nowZ)
         {
             PathNode pathNode = createPathNode();
             pathNode.setXYZ(nowX, nowY, nowZ);
             this.pathQueue.offerLast(pathNode);
         }
         
         int index = 0;
         int size = pathList.size();
         while(index < size)
         {
             int x = pathList.get(index++);
             int y = pathList.get(index++);
             int z = pathList.get(index++);
         
             PathNode pathNode = createPathNode();
             pathNode.setXYZ(x,y,z);
             this.pathQueue.offerLast(pathNode);
         }
         ```

      6.  


